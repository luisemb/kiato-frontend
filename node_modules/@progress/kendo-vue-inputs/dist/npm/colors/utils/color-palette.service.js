"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ColorPaletteService = void 0;
var misc_1 = require("./misc");
var kendo_drawing_1 = require("@progress/kendo-drawing");
/**
 * @hidden
 */
var ColorPaletteService = /** @class */ (function () {
    function ColorPaletteService() {
        this.colorRows = [];
    }
    ColorPaletteService.prototype.setColorMatrix = function (palette, columns) {
        this.colorRows = [];
        if (!((0, misc_1.isPresent)(palette) && palette.length)) {
            return;
        }
        columns = columns || palette.length;
        for (var start = 0; start < palette.length; start += columns) {
            var row = palette.slice(start, columns + start);
            this.colorRows.push(row);
        }
    };
    ColorPaletteService.prototype.isInColors = function (colors, current) {
        return colors.some(function (c) { return c === current; });
    };
    ColorPaletteService.prototype.getCellCoordsFor = function (color) {
        if (!(0, misc_1.isPresent)(color)) {
            return;
        }
        var parsedColor = color ? (0, kendo_drawing_1.parseColor)(color, true) : color;
        var colors = [color];
        if ((0, misc_1.isPresent)(parsedColor)) {
            colors.push(parsedColor.toCss(), parsedColor.toCssRgba());
        }
        for (var row = 0; row < this.colorRows.length; row++) {
            for (var col = 0; col < this.colorRows[row].length; col++) {
                if (this.isInColors(colors, this.colorRows[row][col])) {
                    return { row: row, col: col };
                }
            }
        }
    };
    ColorPaletteService.prototype.getColorAt = function (cellCoords) {
        if (!((0, misc_1.isPresent)(cellCoords) && (0, misc_1.isPresent)(this.colorRows[cellCoords.row]))) {
            return;
        }
        return this.colorRows[cellCoords.row][cellCoords.col];
    };
    ColorPaletteService.prototype.getNextCell = function (current, horizontalStep, verticalStep) {
        if (!((0, misc_1.isPresent)(current) && (0, misc_1.isPresent)(current.row) && (0, misc_1.isPresent)(current.col))) {
            return { row: 0, col: 0 };
        }
        var row = this.clampIndex(current.row + verticalStep, this.colorRows.length - 1);
        var col = this.clampIndex(current.col + horizontalStep, this.colorRows[row].length - 1);
        return { row: row, col: col };
    };
    ColorPaletteService.prototype.clampIndex = function (index, max) {
        var minArrayIndex = 0;
        if (index < minArrayIndex) {
            return minArrayIndex;
        }
        if (index > max) {
            return max;
        }
        return index;
    };
    return ColorPaletteService;
}());
exports.ColorPaletteService = ColorPaletteService;
