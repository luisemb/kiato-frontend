var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
import { getAllDirectIndirectChildrenIds, areAllDirectChildrenChecked, getAllParents } from './utils/itemUtils.js';
import { getDirectParentId, getItemById } from './utils/itemIdUtils.js';
import { isArray, getNestedValue } from './utils/misc.js';
import { CHILDREN_FIELD } from './utils/consts.js';
/**
 *
 * A helper function which updates the check descriptor.
 *
 * {% meta height:650 %}
 * {% embed_file checkbox/checkbox-helper/main.vue preview %}
 * {% embed_file checkbox/checkbox-helper/main.js %}
 * {% endmeta %}
 *
 *  #### Parameters
 *  ##### event <span class='code'>[TreeViewExpandChangeEvent]({% slug api_treeview_treeviewexpandchangeevent %})</span>
 *  The event that triggered the change.
 *
 *  ##### check <span class='code'>string[] | [TreeViewCheckDescriptor]({% slug api_treeview_treeviewcheckdescriptor %})</span>
 *  The check descriptor that will be updated.
 *
 *  ##### data? <span class='code'>any[] | null</span>
 *  The TreeView items.
 *
 *  ##### settings <span class='code'>[TreeViewCheckChangeSettings]({% slug api_treeview_treeviewcheckchangesettings %})</span>
 *  The additional settings that configure the update of the check descriptor.
 *
 *  ##### childrenField? <span class='code'>string</span>
 *  The field that points to the dataItem sub items. Defaults to `items`.
 *  The default behavior allows the selection of multiple items.
 *
 *  #### Returns
 *  <span class='code'>any</span> - The updated copy of the input check descriptor.
 */
export function handleTreeViewCheckChange(event, check, data, settings, childrenField) {
    if (settings === void 0) { settings = {}; }
    if (!data || !data.length) {
        return [];
    }
    var _a = parseOperation(check), ids = _a.ids, idField = _a.idField;
    var itemId = idField ? getNestedValue(idField, event.item) : event.itemHierarchicalIndex;
    var idIndex = ids.indexOf(itemId);
    var itemJustChecked = idIndex === -1;
    var subItemsField = childrenField || CHILDREN_FIELD;
    var newIds;
    if (settings.singleMode) {
        newIds = itemJustChecked ? [itemId] : [];
    }
    else {
        newIds = ids.slice();
        itemJustChecked ? newIds.push(itemId) : newIds.splice(idIndex, 1);
        if (settings.checkChildren) {
            checkChildren(event.item, event.itemHierarchicalIndex, itemJustChecked, idField, subItemsField, newIds);
        }
        if (settings.checkParents) {
            checkParents(event.itemHierarchicalIndex, itemJustChecked, idField, subItemsField, newIds, data);
        }
    }
    return isArray(check) ? newIds : Object.assign({}, check, { ids: newIds });
}
function parseOperation(operation) {
    var ids;
    var idField = undefined;
    if (isArray(operation)) {
        ids = operation;
    }
    else {
        ids = operation.ids || [];
        idField = operation.idField;
    }
    return { ids: ids, idField: idField };
}
function checkChildren(item, itemHierarchicalIndex, itemJustChecked, idField, childrenField, ids) {
    getAllDirectIndirectChildrenIds(item, itemHierarchicalIndex, childrenField, idField).forEach(function (itemId) {
        if (itemJustChecked && ids.indexOf(itemId) === -1) {
            ids.push(itemId);
        }
        else if (!itemJustChecked && ids.indexOf(itemId) > -1) {
            ids.splice(ids.indexOf(itemId), 1);
        }
    });
}
function checkParents(itemHierarchicalIndex, itemJustChecked, idField, childrenField, ids, data) {
    var it = makeParentsIterator();
    var result = it.next();
    itemJustChecked ? check() : uncheck();
    function check() {
        // Check all parents which have all their children checked.
        while (!result.done) {
            var _a = result.value, id = _a.id, item = _a.item;
            // The first check is needed. However, it is not sure whether to stop the entire loop.
            if (ids.indexOf(id) === -1 &&
                areAllDirectChildrenChecked(item, id, idField, childrenField, ids)) {
                ids.push(id);
                result = it.next();
            }
            else {
                break;
            }
        }
    }
    function uncheck() {
        // Uncheck parents until an already unchecked parent is reached.
        while (!result.done) {
            var id = result.value.id;
            var idIndex = ids.indexOf(id);
            if (idIndex > -1) {
                ids.splice(idIndex, 1);
                result = it.next();
            }
            else {
                break;
            }
        }
    }
    // When called for unchecking, the parent items are not needed.
    // That is why, for optimization, they are not returned.
    function makeParentsIterator() {
        var parents, i, parentId;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    if (!idField) return [3 /*break*/, 5];
                    parents = getAllParents(itemHierarchicalIndex, childrenField, data);
                    i = parents.length - 1;
                    _a.label = 1;
                case 1:
                    if (!(i > -1)) return [3 /*break*/, 4];
                    return [4 /*yield*/, { id: getNestedValue(idField, parents[i]), item: itemJustChecked ? parents[i] : undefined }];
                case 2:
                    _a.sent();
                    _a.label = 3;
                case 3:
                    i--;
                    return [3 /*break*/, 1];
                case 4: return [3 /*break*/, 8];
                case 5:
                    parentId = getDirectParentId(itemHierarchicalIndex);
                    _a.label = 6;
                case 6:
                    if (!parentId) return [3 /*break*/, 8];
                    return [4 /*yield*/, { id: parentId, item: itemJustChecked ? getItemById(parentId, data, childrenField) : undefined }];
                case 7:
                    _a.sent();
                    parentId = getDirectParentId(parentId);
                    return [3 /*break*/, 6];
                case 8: return [2 /*return*/];
            }
        });
    }
}
