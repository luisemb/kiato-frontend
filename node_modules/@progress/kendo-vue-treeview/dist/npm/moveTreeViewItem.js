"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.moveTreeViewItem = void 0;
var itemUtils_1 = require("./utils/itemUtils");
var itemIdUtils_1 = require("./utils/itemIdUtils");
var consts_1 = require("./utils/consts");
/**
 *  A helper function which moves a TreeView item in an immutable way.
 *
 * {% meta height:400 %}
 * {% embed_file drag/single/main.vue preview %}
 * {% embed_file drag/single/main.js %}
 * {% endmeta %}
 *
 *  #### Parameters
 *  ##### sourceItemHierarchicalIndex <span class='code'>string</span>
 *  The hierarchical index of the item that will be moved.
 *
 *  ##### sourceData <span class='code'>any[] | null | undefined</span>
 *  The tree which contains the item that will be moved.
 *
 *  ##### operation <span class='code'>"before" | "after" | "child"</span>
 *  The specific move operation.
 *
 *  The available options are:
 *   * `before`&mdash;Indicates that the source item will become the previous sibling of the target item.
 *   * `after`&mdash;Indicates that the source item will become the next sibling of the target item.
 *   * `child`&mdash;Indicates that the source item will become a child of the target item.
 *
 *  ##### targetItemHierarchicalIndex <span class='code'>string</span>
 *  The hierarchical index of the item next to which the source item will be moved.
 *
 *  ##### targetData? <span class='code'>any[] | null</span>
 *  The tree which contains the target item.
 *  If the argument is skipped, then the move operation will be executed within the same tree.
 *  Setting the `sourceData` and `targetData` arguments to the same tree is also supported.
 *
 *  ##### childrenField? <span class='code'>string</span>
 *  The field that points to the dataItem sub items. Defaults to `items`.
 *
 *  #### Returns
 *  <span class='code'>any[] | { sourceData: any[]; targetData: any[]; }</span> - The updated copies of the `sourceData` and `targetData` input arguments.
 *  If `targetData` is not passed, then only the updated copy of the `sourceData` will be returned.
 */
var moveTreeViewItem = function (sourceItemHierarchicalIndex, sourceData, operation, targetItemHierarchicalIndex, targetData, childrenField) {
    var subItemsField = childrenField || consts_1.CHILDREN_FIELD;
    if (!validateInput()) {
        return prepareInputDataForReturn();
    }
    var sourceItem = (0, itemIdUtils_1.getItemById)(sourceItemHierarchicalIndex, sourceData, subItemsField);
    if (!sourceItem) {
        return prepareInputDataForReturn();
    }
    // The source and the target tree are the same.
    if (!targetData || targetData === sourceData) {
        if (!validateNoCircularReference()) {
            return prepareInputDataForReturn();
        }
        var updatedSourceData = (0, itemUtils_1.removeItem)(sourceItemHierarchicalIndex, subItemsField, sourceData);
        var resultData = (0, itemUtils_1.addItem)(sourceItem, operation, subItemsField, (0, itemIdUtils_1.getDecrementedItemIdAfterRemoval)(sourceItemHierarchicalIndex, targetItemHierarchicalIndex), updatedSourceData);
        // A simpler output is explicitly returned when the source and the target tree are
        // the same, that is, the targetData argument is skipped.
        return targetData ? { sourceData: resultData, targetData: resultData } : resultData;
    }
    else {
        var updatedSource = (0, itemUtils_1.removeItem)(sourceItemHierarchicalIndex, subItemsField, sourceData);
        var updatedTarget = (0, itemUtils_1.addItem)(sourceItem, operation, subItemsField, targetItemHierarchicalIndex, targetData);
        return { sourceData: updatedSource, targetData: updatedTarget };
    }
    function prepareInputDataForReturn() {
        return targetData ? { sourceData: sourceData, targetData: targetData } : sourceData;
    }
    function validateNoCircularReference() {
        return !"".concat(targetItemHierarchicalIndex, "_").startsWith("".concat(sourceItemHierarchicalIndex, "_"));
    }
    function validateInput() {
        if (!sourceData || !sourceData.length ||
            !sourceItemHierarchicalIndex || !targetItemHierarchicalIndex) {
            return false;
        }
        if (targetData && !targetData.length) {
            // Dropping over an empty tree is not supported.
            return false;
        }
        // Validate that the target item exists.
        var data = !targetData || targetData === sourceData ? sourceData : targetData;
        if (!(0, itemIdUtils_1.getItemById)(targetItemHierarchicalIndex, data, subItemsField)) {
            return false;
        }
        return true;
    }
};
exports.moveTreeViewItem = moveTreeViewItem;
