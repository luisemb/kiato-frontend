// @ts-ignore
import * as Vue from 'vue';
var allVue = Vue;
var gh = allVue.h;
var isV3 = allVue.version && allVue.version[0] === '3';
import { getListeners, getTemplate, getter, templateRendering, validatePackage, shouldShowValidationUI, WatermarkOverlay, guid } from '@progress/kendo-vue-common';
import { packageMetadata } from '../package-metadata';
import { Tile } from './Tile';
/**
 * @hidden
 */
var AUTO_FLOW_CLASSES = {
  'column': 'k-grid-flow-col',
  'row': 'k-grid-flow-row',
  'column dense': 'k-grid-flow-col-dense',
  'row dense': 'k-grid-flow-row-dense',
  'unset': 'k-grid-flow-unset'
};
/**
 * @hidden
 */
var TileLayoutVue2 = {
  name: 'KendoTileLayout',
  props: {
    id: String,
    dir: String,
    gap: Object,
    columns: Number,
    columnWidth: [Number, String],
    rowHeight: [Number, String],
    dataItemKey: String,
    items: Array,
    positions: Array,
    autoFlow: {
      type: String,
      default: 'column',
      validator: function validator(value) {
        return ['column', 'row', 'column dense', 'row dense', 'unset'].includes(value);
      }
    },
    ignoreDrag: Function
  },
  created: function created() {
    validatePackage(packageMetadata);
    this.showLicenseWatermark = shouldShowValidationUI(packageMetadata);
  },
  data: function data() {
    return {
      currentPositions: [],
      showLicenseWatermark: false
    };
  },
  computed: {
    compPositions: function compPositions() {
      if (this.positions) {
        return this.positions.map(function (p, i) {
          return Object.assign({
            order: i,
            rowSpan: 1,
            colSpan: 1
          }, p);
        });
      }
      if (this.items && this.currentPositions.length) {
        return this.currentPositions.map(function (p, i) {
          return Object.assign({
            order: i,
            rowSpan: 1,
            colSpan: 1
          }, p);
        });
      }
      return (this.$props.items || []).map(function (p, i) {
        return Object.assign({
          order: i,
          rowSpan: 1,
          colSpan: 1
        }, p.defaultPosition);
      });
    },
    wrapperClass: function wrapperClass() {
      var _a;
      var autoFlow = this.$props.autoFlow;
      return _a = {
        'k-tilelayout': true,
        'k-pos-relative': true
      }, _a[AUTO_FLOW_CLASSES[autoFlow]] = true, _a;
    }
  },
  // @ts-ignore
  setup: !isV3 ? undefined : function () {
    var v3 = !!isV3;
    return {
      v3: v3
    };
  },
  render: function render(createElement) {
    var h = gh || createElement;
    var _a = this.$props,
      _b = _a.columns,
      columns = _b === void 0 ? 3 : _b,
      _c = _a.columnWidth,
      columnWidth = _c === void 0 ? '1fr' : _c,
      gap = _a.gap,
      _d = _a.rowHeight,
      rowHeight = _d === void 0 ? '1fr' : _d,
      _e = _a.items,
      items = _e === void 0 ? [] : _e;
    var gapValue = gap ? "".concat(typeof gap.rows === 'number' ? gap.rows + 'px' : gap.rows) + ' ' + "".concat(typeof gap.columns === 'number' ? gap.columns + 'px' : gap.columns) : 16;
    var tileLayoutStyles = {
      gridTemplateColumns: "repeat(".concat(columns, ", minmax(0px, ").concat(typeof columnWidth === 'number' ? columnWidth + 'px' : columnWidth, "))"),
      gridAutoRows: "minmax(0px, ".concat(typeof rowHeight === 'number' ? rowHeight + 'px' : rowHeight, ")"),
      gap: gapValue,
      padding: gapValue
    };
    var watermark = this.showLicenseWatermark ? h(WatermarkOverlay) : null;
    return h("div", {
      dir: this.$props.dir,
      attrs: this.v3 ? undefined : {
        dir: this.$props.dir,
        id: this.$props.id,
        role: 'list'
      },
      "class": this.wrapperClass,
      style: tileLayoutStyles,
      id: this.$props.id,
      role: 'list'
    }, [items.map(function (tile, index) {
      var _this = this;
      var tileTitleId = tile && tile.id || guid();
      var item = templateRendering.call(this, tile.item, getListeners.call(this));
      var itemContent = getTemplate.call(this, {
        h: h,
        template: item,
        defaultRendering: null,
        additionalProps: {
          tile: tile,
          index: index
        }
      });
      var header = templateRendering.call(this, tile.header, getListeners.call(this));
      var headerContent = getTemplate.call(this, {
        h: h,
        template: header,
        defaultRendering: null,
        additionalProps: {
          tile: tile,
          index: index,
          id: tileTitleId,
          headerText: tile.headerText
        }
      });
      var body = templateRendering.call(this, tile.body, getListeners.call(this));
      var bodyContent = getTemplate.call(this, {
        h: h,
        template: body,
        defaultRendering: null,
        additionalProps: {
          tile: tile,
          index: index,
          bodyText: tile.bodyText
        }
      });
      return (
        // @ts-ignore function children
        h(Tile, {
          key: this.$props.dataItemKey ? getter(this.$props.dataItemKey)(tile) : index,
          onUpdate: this.updateHandle,
          on: this.v3 ? undefined : {
            "update": this.updateHandle
          },
          defaultPosition: this.compPositions[index],
          attrs: this.v3 ? undefined : {
            defaultPosition: this.compPositions[index],
            index: index,
            resizable: tile.resizable,
            reorderable: tile.reorderable,
            tile: tile,
            hintClass: tile.hintClass,
            hintStyle: tile.hintStyle,
            ignoreDrag: this.$props.ignoreDrag,
            "aria-describedby": tileTitleId,
            "tab-index": tile.tabIndex
          },
          index: index,
          resizable: tile.resizable,
          reorderable: tile.reorderable,
          style: tile.style,
          "class": tile.class,
          tile: tile,
          hintClass: tile.hintClass,
          hintStyle: tile.hintStyle,
          ignoreDrag: this.$props.ignoreDrag,
          "aria-describedby": tileTitleId,
          "tab-index": tile.tabIndex
        }, this.v3 ? function () {
          return [tile.item ? itemContent : [h("div", {
            "class": "k-tilelayout-item-header k-card-header"
          }, [tile.header ? headerContent : h("h5", {
            "class": 'k-card-title',
            id: tileTitleId,
            attrs: _this.v3 ? undefined : {
              id: tileTitleId
            }
          }, [tile.headerText])]), h("div", {
            "class": 'k-tilelayout-item-body k-card-body'
          }, [tile.body ? bodyContent : tile.bodyText])]];
        } : [tile.item ? itemContent : [h("div", {
          "class": "k-tilelayout-item-header k-card-header"
        }, [tile.header ? headerContent : h("h5", {
          "class": 'k-card-title',
          id: tileTitleId,
          attrs: _this.v3 ? undefined : {
            id: tileTitleId
          }
        }, [tile.headerText])]), h("div", {
          "class": 'k-tilelayout-item-body k-card-body'
        }, [tile.body ? bodyContent : tile.bodyText])]])
      );
    }, this), watermark]);
  },
  methods: {
    focus: function focus() {
      if (this.$el) {
        this.$el.focus();
      }
    },
    updateHandle: function updateHandle(index, dOrder, dCol, dRowSpan, dColSpan, isResized) {
      if (dRowSpan === void 0) {
        dRowSpan = 0;
      }
      if (dColSpan === void 0) {
        dColSpan = 0;
      }
      if (dOrder === 0 && dCol === 0 && !dColSpan && !dRowSpan) {
        return;
      }
      var shouldUpdate = false;
      var positions = this.compPositions.map(function (p) {
        return Object.assign({}, p);
      });
      // reordering:
      var current = positions[index];
      var other = positions.find(function (item) {
        return item.order === current.order + dOrder;
      });
      if (other && other !== current) {
        current.order += dOrder;
        other.order += -dOrder;
        shouldUpdate = true;
      }
      var proposedCol = current.col + dCol;
      if (dCol !== 0 && proposedCol >= 1 && proposedCol + current.colSpan <= (this.$props.columns || 3) + 1) {
        current.col = proposedCol;
        shouldUpdate = true;
      }
      // resizing:
      var proposedColSpan = current.colSpan + dColSpan;
      if (dColSpan && proposedColSpan >= 1 && proposedColSpan + current.col <= (this.$props.columns || 3) + 1) {
        current.colSpan = proposedColSpan;
        shouldUpdate = true;
      }
      var proposedRowSpan = current.rowSpan + dRowSpan;
      if (dRowSpan && proposedRowSpan >= 1) {
        current.rowSpan = proposedRowSpan;
        shouldUpdate = true;
      }
      if (shouldUpdate) {
        this.currentPositions = positions;
        if (isResized) {
          this.$emit('tileresize', {
            value: positions,
            index: index,
            rowSpan: dRowSpan,
            colSpan: dColSpan
          });
        }
        this.$emit('reposition', {
          value: positions,
          index: index,
          row: dOrder,
          col: dCol
        });
      }
    }
  }
};
/**
 * @hidden
 */
var TileLayout = TileLayoutVue2;
export { TileLayout, TileLayoutVue2 };