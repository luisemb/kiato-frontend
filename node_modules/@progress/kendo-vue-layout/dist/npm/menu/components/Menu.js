"use strict";

var __assign = undefined && undefined.__assign || function () {
  __assign = Object.assign || function (t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) {
        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
      }
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MenuVue2 = exports.Menu = void 0;
// @ts-ignore
var Vue = require("vue");
var allVue = Vue;
var gh = allVue.h;
var isV3 = allVue.version && allVue.version[0] === '3';
var kendo_vue_common_1 = require("@progress/kendo-vue-common");
var kendo_vue_common_2 = require("@progress/kendo-vue-common");
var itemsIdsUtils_1 = require("../utils/itemsIdsUtils");
var prepareInputItemsForInternalWork_1 = require("../utils/prepareInputItemsForInternalWork");
var getNewItemIdUponKeyboardNavigation_1 = require("../utils/getNewItemIdUponKeyboardNavigation");
var hoverDelay_1 = require("../utils/hoverDelay");
var MenuItemInternalsList_1 = require("./MenuItemInternalsList");
var DirectionHolder_1 = require("../utils/DirectionHolder");
var MouseOverHandler_1 = require("../utils/MouseOverHandler");
var package_metadata_1 = require("../../package-metadata");
/**
 * @hidden
 */
var MenuVue2 = {
  name: 'KendoMenu',
  props: {
    vertical: {
      type: Boolean,
      default: false
    },
    items: Array,
    dir: String,
    hoverOpenDelay: {
      type: Number,
      default: undefined
    },
    hoverCloseDelay: {
      type: Number,
      default: undefined
    },
    openOnClick: Boolean,
    itemRender: [String, Object, Function],
    linkRender: [String, Object, Function],
    customCloseItemIds: Array
  },
  created: function created() {
    (0, kendo_vue_common_2.validatePackage)(package_metadata_1.packageMetadata);
    this.mouseOverHandler = new MouseOverHandler_1.MouseOverHandler(this.$props.openOnClick, this.reset, this.onItemMouseOver);
    // private itemHoverRequest: any;
    // private itemLeaveRequest: any;
    // private menuWrapperEl: any;
    this.guid = (0, kendo_vue_common_2.guid)();
    this.directionHolder = new DirectionHolder_1.DirectionHolder();
    this.inputItems = [];
    this.currentItems = [];
    // private mouseOverHandler: MouseOverHandler;
  },

  mounted: function mounted() {
    this.isFirstRender = false;
    this.menuWrapperEl = (0, kendo_vue_common_1.getRef)(this, 'menuWrapper');
  },
  updated: function updated() {
    // Reset the Menu upon big UI changes
    // to avoid misleading the user and to
    // keep the component consistent.
    // if (Boolean(prevProps.vertical) !== Boolean(this.$props.vertical) ||
    //     this.directionHolder.hasDirectionChanged()) {
    //     this.reset();
    // }
    this.mouseOverHandler.OpenOnClick = this.$props.openOnClick;
  },
  destroyed: !!isV3 ? undefined : function () {
    this.clearItemHoverAndLeaveRequestsIfApplicable();
  },
  // @ts-ignore
  unmounted: function unmounted() {
    this.clearItemHoverAndLeaveRequestsIfApplicable();
  },
  data: function data() {
    return {
      focusedItemId: itemsIdsUtils_1.EMPTY_ID,
      hoveredItemId: itemsIdsUtils_1.EMPTY_ID,
      tabbableItemId: itemsIdsUtils_1.ZERO_LEVEL_ZERO_ITEM_ID,
      isFirstRender: true
    };
  },
  computed: {
    menuClassName: function menuClassName() {
      return {
        'k-widget': true,
        'k-reset': true,
        'k-header': true,
        'k-menu': true,
        'k-menu-horizontal': !this.$props.vertical,
        'k-menu-vertical': this.$props.vertical
      };
    }
  },
  // @ts-ignore
  setup: !isV3 ? undefined : function () {
    var v3 = !!isV3;
    return {
      v3: v3
    };
  },
  render: function render(createElement) {
    var h = gh || createElement;
    this.prepareItems();
    if (!this.isFirstRender) {
      this.directionHolder.setIsDirectionRightToLeft(this.checkIsDirectionRightToLeft());
    }
    var lastItemIdToBeOpened = this.hoveredItemId ? this.hoveredItemId : this.focusedItemId ? (0, itemsIdsUtils_1.getDirectParentId)(this.focusedItemId) : itemsIdsUtils_1.EMPTY_ID;
    return h("div", {
      "class": this.getMenuWrapperClassName(),
      ref: (0, kendo_vue_common_1.setRef)(this, 'menuWrapper')
    }, [
    // @ts-ignore
    h(MenuItemInternalsList_1.MenuItemInternalsList, {
      "class": this.menuClassName,
      "aria-orientation": this.$props.vertical ? 'vertical' : undefined,
      attrs: this.v3 ? undefined : {
        "aria-orientation": this.$props.vertical ? 'vertical' : undefined,
        items: this.currentItems,
        isMenuVertical: this.$props.vertical,
        isDirectionRightToLeft: this.directionHolder.getIsDirectionRightToLeft(),
        focusedItemId: this.focusedItemId,
        lastItemIdToBeOpened: lastItemIdToBeOpened,
        tabbableItemId: this.tabbableItemId,
        itemRender: kendo_vue_common_1.templateRendering.call(this, this.$props.itemRender, kendo_vue_common_1.getListeners.call(this)),
        linkRender: kendo_vue_common_1.templateRendering.call(this, this.$props.linkRender, kendo_vue_common_1.getListeners.call(this)),
        menuGuid: this.guid,
        originalItemNeeded: this.getInputItem
      },
      items: this.currentItems,
      isMenuVertical: this.$props.vertical,
      isDirectionRightToLeft: this.directionHolder.getIsDirectionRightToLeft(),
      focusedItemId: this.focusedItemId,
      lastItemIdToBeOpened: lastItemIdToBeOpened,
      tabbableItemId: this.tabbableItemId,
      itemRender: kendo_vue_common_1.templateRendering.call(this, this.$props.itemRender, kendo_vue_common_1.getListeners.call(this)),
      linkRender: kendo_vue_common_1.templateRendering.call(this, this.$props.linkRender, kendo_vue_common_1.getListeners.call(this)),
      menuGuid: this.guid,
      onMouseleave: this.onItemMouseLeave,
      on: this.v3 ? undefined : {
        "mouseleave": this.onItemMouseLeave,
        "mouseover": this.onItemMouseOver,
        "mousedown": this.onItemMouseDown,
        "keydown": this.onKeyDown,
        "focus": this.onItemFocus,
        "click": this.onItemClick,
        "blur": this.onItemBlur
      },
      onMouseover: this.onItemMouseOver,
      onMousedown: this.onItemMouseDown,
      onKeydown: this.onKeyDown,
      onFocus: this.onItemFocus,
      onClick: this.onItemClick,
      onBlur: this.onItemBlur,
      originalItemNeeded: this.getInputItem
    })]);
  },
  methods: {
    reset: function reset() {
      this.clearItemHoverAndLeaveRequestsIfApplicable();
      this.focusedItemId = itemsIdsUtils_1.EMPTY_ID;
      this.hoveredItemId = itemsIdsUtils_1.EMPTY_ID;
      this.tabbableItemId = itemsIdsUtils_1.ZERO_LEVEL_ZERO_ITEM_ID;
    },
    onKeyDown: function onKeyDown(event) {
      // The focusedItemId may be empty when contentRender is used.
      // For example, content with input.
      if (this.focusedItemId !== itemsIdsUtils_1.EMPTY_ID) {
        var currentItem = (0, itemsIdsUtils_1.getItemById)(this.focusedItemId, this.currentItems);
        var newItemId = (0, getNewItemIdUponKeyboardNavigation_1.getNewItemIdUponKeyboardNavigation)(this.currentItems, currentItem.id, event.keyCode, event.key, this.$props.vertical, this.directionHolder.getIsDirectionRightToLeft());
        if (currentItem.id !== newItemId) {
          event.preventDefault();
          this.setFocusedItemId(newItemId);
        }
        if ((event.keyCode === kendo_vue_common_2.Keys.enter || event.keyCode === kendo_vue_common_2.Keys.space) && !currentItem.disabled) {
          this.mouseOverHandler.handleItemSelectedViaKeyboard();
          this.dispatchSelectEventIfWired(event, currentItem.id);
          if (!event.defaultPrevented && currentItem.items.length === 0 && currentItem.url && kendo_vue_common_1.canUseDOM) {
            window.location.assign(currentItem.url);
          }
        }
      }
    },
    onItemMouseOver: function onItemMouseOver(itemId) {
      if (this.mouseOverHandler.IsMouseOverEnabled) {
        // The `over` event can get fired even without actually leaving the item.
        // For example, move the mouse little by little over the item content.
        this.clearItemHoverAndLeaveRequestsIfApplicable();
        var that_1 = this;
        this.itemHoverRequest = window.setTimeout(function () {
          that_1.setHoveredItemId(itemId);
          that_1.itemHoverRequest = null;
        }, (0, hoverDelay_1.getHoverOpenDelay)(__assign({}, this.$props)));
      }
    },
    onItemMouseLeave: function onItemMouseLeave(itemId) {
      if (this.mouseOverHandler.IsMouseOverEnabled && this.isItemWithDefaultClose(itemId)) {
        // Both the `leave` and `hover` requests are cleared
        // to be defensive and consistent with the `over` handler.
        this.clearItemHoverAndLeaveRequestsIfApplicable();
        var that_2 = this;
        this.itemLeaveRequest = window.setTimeout(function () {
          that_2.setHoveredItemId(itemsIdsUtils_1.EMPTY_ID);
          that_2.itemLeaveRequest = null;
        }, (0, hoverDelay_1.getHoverCloseDelay)(__assign({}, this.$props)));
      }
    },
    onItemMouseDown: function onItemMouseDown() {
      this.mouseOverHandler.handleItemMouseDown();
    },
    onItemFocus: function onItemFocus(itemId) {
      this.setFocusedItemId(itemId);
      this.mouseOverHandler.handleItemFocus();
    },
    onItemClick: function onItemClick(event, itemId) {
      var item = (0, itemsIdsUtils_1.getItemById)(itemId, this.currentItems);
      if (!item.disabled) {
        this.setFocusedItemId(itemId);
        this.mouseOverHandler.handleItemClick(itemId, this.isItemWithDefaultClose(itemId));
        this.dispatchSelectEventIfWired(event, itemId);
        if (!event.defaultPrevented && item.url && kendo_vue_common_1.canUseDOM) {
          window.location.assign(item.url);
        }
      }
    },
    onItemBlur: function onItemBlur(itemId) {
      if (this.isItemWithDefaultClose(itemId)) {
        this.setFocusedItemId(itemsIdsUtils_1.EMPTY_ID);
      }
    },
    getInputItem: function getInputItem(itemId) {
      return (0, itemsIdsUtils_1.getItemById)(itemId, this.inputItems);
    },
    setFocusedItemId: function setFocusedItemId(focusedItemId) {
      var tabbableItemId = focusedItemId === itemsIdsUtils_1.EMPTY_ID ? this.tabbableItemId : (0, itemsIdsUtils_1.getRootParentId)(focusedItemId);
      var hoveredItemId = focusedItemId === itemsIdsUtils_1.EMPTY_ID || (0, itemsIdsUtils_1.isIdEmptyOrZeroLevel)(this.hoveredItemId) && (0, itemsIdsUtils_1.isIdEmptyOrZeroLevel)(focusedItemId) ? this.hoveredItemId : itemsIdsUtils_1.EMPTY_ID;
      this.hoveredItemId = hoveredItemId;
      this.focusedItemId = focusedItemId;
      this.tabbableItemId = tabbableItemId;
    },
    setHoveredItemId: function setHoveredItemId(hoveredItemId) {
      if ((0, itemsIdsUtils_1.isIdEmptyOrZeroLevel)(hoveredItemId) && (0, itemsIdsUtils_1.isIdEmptyOrZeroLevel)(this.focusedItemId)) {
        this.hoveredItemId = hoveredItemId;
      } else {
        this.hoveredItemId = hoveredItemId;
        this.focusedItemId = itemsIdsUtils_1.EMPTY_ID;
        this.tabbableItemId = itemsIdsUtils_1.ZERO_LEVEL_ZERO_ITEM_ID;
      }
    },
    getMenuWrapperClassName: function getMenuWrapperClassName() {
      return {
        'k-rtl': this.directionHolder.getIsDirectionRightToLeft()
      };
    },
    clearItemHoverAndLeaveRequestsIfApplicable: function clearItemHoverAndLeaveRequestsIfApplicable() {
      if (this.itemHoverRequest) {
        clearTimeout(this.itemHoverRequest);
        this.itemHoverRequest = null;
      }
      if (this.itemLeaveRequest) {
        clearTimeout(this.itemLeaveRequest);
        this.itemLeaveRequest = null;
      }
    },
    isItemWithDefaultClose: function isItemWithDefaultClose(itemId) {
      return !this.$props.customCloseItemIds || this.$props.customCloseItemIds.indexOf(itemId) === -1;
    },
    checkIsDirectionRightToLeft: function checkIsDirectionRightToLeft() {
      return this.$props.dir !== undefined ? this.$props.dir === 'rtl' : this.menuWrapperEl && getComputedStyle(this.menuWrapperEl).direction === 'rtl';
    },
    prepareItems: function prepareItems() {
      var _a = prepareInputItemsForInternalWork_1.prepareInputItemsForInternalWork.call(this, this.$props.items),
        items = _a.items,
        inputItems = _a.inputItems;
      this.currentItems = items;
      this.inputItems = inputItems;
    },
    dispatchSelectEventIfWired: function dispatchSelectEventIfWired(event, itemId) {
      this.$emit('select', {
        event: event,
        compontent: this,
        item: this.getInputItem(itemId),
        itemId: itemId
      });
    }
  }
};
exports.MenuVue2 = MenuVue2;
/**
 *
 * Represents the [Kendo UI for Vue Menu component]({% slug overview_menu %}).
 *
 *
 * ### props <span class='code'>Readonly&lt;[MenuProps]({% slug api_layout_menuprops %})&gt;</span>
 * The props of the Menu component.
 *
 */
var Menu = MenuVue2;
exports.Menu = Menu;